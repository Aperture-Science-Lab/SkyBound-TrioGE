#include "FlightController.h"
#include <stdio.h>
#include <iostream>

FlightController::FlightController() {
    // Initial Spawn State
    player.position = Vector3f(0.0f, 40.0f, 0.0f);
    player.velocity = Vector3f(0.0f, 0.0f, 0.0f);
    player.acceleration = Vector3f(0.0f, 0.0f, 0.0f);

    player.forward = Vector3f(0.0f, 0.0f, -1.0f);
    player.up = Vector3f(0.0f, 1.0f, 0.0f);
    player.right = Vector3f(1.0f, 0.0f, 0.0f);

    player.throttle = 0.0f; // Start with 0 throttle

    cameraMode = 0;
    cameraDist = 30.0f;
    cameraHeight = 8.0f;

    isCrashed = false;
    isGrounded = false;
    viewBobTimer = 0.0f;
    currentFOV = 45.0f;

    for(int i=0; i<256; i++) keyState[i] = false;
}

void FlightController::reset() {
    // Reset to initial spawn state
    player.position = Vector3f(0.0f, 40.0f, 0.0f);
    player.velocity = Vector3f(0.0f, 0.0f, 0.0f);
    player.acceleration = Vector3f(0.0f, 0.0f, 0.0f);

    player.forward = Vector3f(0.0f, 0.0f, -1.0f);
    player.up = Vector3f(0.0f, 1.0f, 0.0f);
    player.right = Vector3f(1.0f, 0.0f, 0.0f);

    player.throttle = 0.0f;

    cameraMode = 0;

    isCrashed = false;
    isGrounded = false;
    viewBobTimer = 0.0f;
    currentFOV = 45.0f;

    for(int i=0; i<256; i++) keyState[i] = false;
}

void FlightController::rotateVector(Vector3f& vec, const Vector3f& axis, float angle) {
    float rad = DEG2RAD(angle);
    float c = cos(rad);
    float s = sin(rad);

    Vector3f k = axis.unit();
    
    // Rodrigues' rotation formula
    Vector3f k_cross_v(
        k.y * vec.z - k.z * vec.y,
        k.z * vec.x - k.x * vec.z,
        k.x * vec.y - k.y * vec.x
    );

    float k_dot_v = k.x * vec.x + k.y * vec.y + k.z * vec.z;

    Vector3f term1 = vec * c;
    Vector3f term2 = k_cross_v * s;
    Vector3f term3 = k * (k_dot_v * (1.0f - c));

    vec = term1 + term2 + term3;
}

void FlightController::handleInput(unsigned char key, bool pressed) {
    keyState[key] = pressed;

    if (pressed) {
        if (key == 'c' || key == 'C') {
            cameraMode = !cameraMode;
        }
        // Reset on crash
        if (isCrashed && (key == 'r' || key == 'R')) {
            reset(); // Reset object to initial state
            loadModel("models/plane/mitsubishi_a6m2_zero_model_11.3ds");
        }
    }
}

void FlightController::handleMouse(int x, int y, int centerX, int centerY) {
    if (isCrashed) return; // No control if crashed

    if (x == centerX && y == centerY) return;

    float dx = (float)(x - centerX);
    float dy = (float)(y - centerY);

    float sensitivity = 0.1f;

    // Mouse X -> Roll
    if (fabs(dx) > 0.1f) {
        rotateVector(player.up, player.forward, -dx * sensitivity);
        rotateVector(player.right, player.forward, -dx * sensitivity);
    }

    // Mouse Y -> Pitch
    if (fabs(dy) > 0.1f) {
        rotateVector(player.forward, player.right, -dy * sensitivity);
        rotateVector(player.up, player.right, -dy * sensitivity);
    }

    // Re-orthogonalize
    player.forward = player.forward.unit();
    player.right = player.right.unit();
    player.up = player.up.unit();
    player.right = player.forward.cross(player.up).unit();
    player.up = player.right.cross(player.forward).unit();
}

void FlightController::applyPhysics(float deltaTime) {
    if (isCrashed) return;

    // 1. Thrust (Controlled by W/S)
    Vector3f thrustForce = player.forward * player.throttle * THRUST_POWER;

    // 2. Gravity
    Vector3f gravityForce(0.0f, -GRAVITY * MASS, 0.0f);

    // 3. Lift
    // Lift is perpendicular to velocity, generated by forward speed
    // Simplified: Lift acts in the local UP direction based on speed squared
    float speedSq = player.velocity.x*player.velocity.x + 
                    player.velocity.y*player.velocity.y + 
                    player.velocity.z*player.velocity.z;
    
    Vector3f liftForce = player.up * (speedSq * LIFT_FACTOR);

    // 4. Drag
    // Drag opposes velocity
    Vector3f dragForce = player.velocity * (-DRAG_FACTOR * sqrt(speedSq));

    // Total Force
    Vector3f totalForce = thrustForce + gravityForce + liftForce + dragForce;

    // Integration
    player.acceleration = totalForce * (1.0f / MASS);
    player.velocity = player.velocity + (player.acceleration * deltaTime);
    player.position = player.position + (player.velocity * deltaTime);
    
    // Simple ground friction if on ground
    if (isGrounded) {
        player.velocity = player.velocity * 0.95f; // Friction
    }
}

void FlightController::resolveCollisions(float deltaTime) {
    // Ground Collision
    if (player.position.y <= 0.5f) {
        player.position.y = 0.5f; // Snap to ground
        
        float verticalSpeed = player.velocity.y;
        float forwardSpeed = sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
        
        // Crash Logic
        // If falling too fast OR flying too fast into ground OR pitched down too much
        if (verticalSpeed < -8.0f || (forwardSpeed > 60.0f && player.forward.y < -0.1f)) {
            if (!isCrashed && !isGrounded) {
                isCrashed = true;
                player.velocity = Vector3f(0,0,0);
                player.throttle = 0;
                std::cout << "CRASH! Press R to Restart." << std::endl;
            }
        } else {
            // Safe Landing
            isGrounded = true;
            player.velocity.y = 0;
            // Align to ground (simple)
            if (player.forward.y < 0) player.forward.y = 0;
        }
    } else {
        isGrounded = false;
    }
}

void FlightController::update(float deltaTime) {
    // Throttle Input
    if (!isCrashed) {
        if (keyState['w'] || keyState['W']) player.throttle += 0.5f * deltaTime;
        if (keyState['s'] || keyState['S']) player.throttle -= 0.5f * deltaTime;
        
        // Yaw (Rudder) logic
        if (keyState['a'] || keyState['A']) {
            rotateVector(player.forward, player.up, 40.0f * deltaTime);
            rotateVector(player.right, player.up, 40.0f * deltaTime);
        }
        if (keyState['d'] || keyState['D']) {
            rotateVector(player.forward, player.up, -40.0f * deltaTime);
            rotateVector(player.right, player.up, -40.0f * deltaTime);
        }
    }
    
    // Clamp throttle
    if (player.throttle < 0.0f) player.throttle = 0.0f;
    if (player.throttle > 2.0f) player.throttle = 2.0f; // Max throttle

    applyPhysics(deltaTime);
    resolveCollisions(deltaTime);

    // View Bobbing Calculation
    float speed = sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
    if (speed > 1.0f && !isCrashed) {
        viewBobTimer += deltaTime * (speed * 0.5f); // Frequency depends on speed
    }
}

float FlightController::getFOV() {
    // Dynamic FOV based on speed
    // Base FOV 45, Max adds 45 (total 90) at high speed
    float speed = sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
    float targetFOV = 45.0f + (speed * 0.3f); 
    if (targetFOV > 110.0f) targetFOV = 110.0f;
    
    // Smooth transition
    currentFOV = currentFOV + (targetFOV - currentFOV) * 0.1f;
    return currentFOV;
}

void FlightController::setupCamera() {
    // Calculate Bobbing Offset
    float bobX = sin(viewBobTimer) * 0.1f;
    float bobY = cos(viewBobTimer * 2.0f) * 0.1f;
    
    // Scale bobbing by throttle/speed
    float shakeIntensity = player.throttle * 0.5f;
    Vector3f bobOffset = (player.right * bobX * shakeIntensity) + (player.up * bobY * shakeIntensity);

    if (isCrashed) {
        // Spin camera if crashed
        gluLookAt(player.position.x + 30, player.position.y + 30, player.position.z + 30,
                  player.position.x, player.position.y, player.position.z,
                  0, 1, 0);
        return;
    }

    if (cameraMode == 1) {
        // 1st Person (Cockpit)
        Vector3f camPos = player.position + (player.forward * 4.0f) + (player.up * 1.5f) + bobOffset;
        Vector3f target = camPos + player.forward;
        
        gluLookAt(camPos.x, camPos.y, camPos.z,
                  target.x, target.y, target.z,
                  player.up.x, player.up.y, player.up.z);
    } else {
        // 3rd Person
        Vector3f camPos = player.position - (player.forward * cameraDist) + (player.up * cameraHeight);
        // Apply lag/smoothing or bobbing to 3rd person too if desired
        Vector3f target = player.position + (player.forward * 20.0f);
        
        gluLookAt(camPos.x, camPos.y, camPos.z,
                  target.x, target.y, target.z,
                  player.up.x, player.up.y, player.up.z);
    }
}

void FlightController::loadModel(char* path) {
    model.Load(path);
    for (int i = 0; i < model.numMaterials; i++) {
        model.Materials[i].tex.Load("models/plane/mitsubishi_a6m2_zero_texture.bmp");
        model.Materials[i].textured = true;
    }
}

void FlightController::drawPlane() {
    if(isCrashed) glColor3f(1,0,0); // Tint red if crashed
    else glColor3f(1,1,1);

    glPushMatrix();
    glTranslatef(player.position.x, player.position.y, player.position.z);
    
    // Construct Rotation Matrix
    float rotMatrix[16] = {
        player.right.x, player.right.y, player.right.z, 0,
        player.up.x,    player.up.y,    player.up.z,    0,
        -player.forward.x, -player.forward.y, -player.forward.z, 0,
        0,              0,              0,              1
    };
    
    glMultMatrixf(rotMatrix);
    glScalef(1, 1, 1); 
    glRotatef(90, 1, 0, 0);
    
    model.Draw();
    
    glPopMatrix();
    glColor3f(1,1,1); // Reset color
}